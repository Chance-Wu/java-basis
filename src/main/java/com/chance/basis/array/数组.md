### 1. 简介

Java 提供了容纳==对象==（或者==对象的句柄==）的多种方式。其中内建的类型是数组。此外，Java 的工具（实用程序）库提供了一些 “集合类”。利用这些集合类，我们可以容纳乃至操纵自己的对象。

数组只是容纳对象的一种方式。哪些地方使数组显得如此特别呢? 有两方面的问题将数组与其他集合类型区分开来：==效率和类型==。数组实际代表一个简单的线性序列，它使得元素的访问速度非常快，但我们却要为这种速度付出代价：*创建一个数组对象时，它的大小是固定的，而且不可在那个数组对象的“存在时间”内发生改变*。可创建特定大小的一个数组，然后假如用光了存储空间，就再创建一个新数组，将所有句柄从旧数组移到新数组。这属于“矢量”(Vector)类的行为。然而，由于为这种大小的灵活性要付出较大的代价，所以我们认为矢量的效率并没有数组高。==在Java 中，无论使用的是数组还是集合，都会进行范围检查——若超过边界，就会获得一个RuntimeException(运行期违例)错误==。在 Java 中，由于对数组和集合都要进行范围检查，所以对性能有一定的影响。这再一次反映了数组优于常规集合：创建一 个数组时，可令其容纳一种特定的类型。这意味着可进行编译期类型检查，预防自己设置了错误的类型，或者错误指定了准备提取的类型。考虑到执行效率和类型检查，应尽可能地采用数组。

### 2. 数组初始化

数组代表一系列对象或者基本数据类型，所有==相同的类型==都封装到一起——采用一个统一的标识符名称。数组的定义和使用是通过方==括号索引运算符==进行的([])。为定义一个数组，只需在类型名后简单地跟随一对 空方括号即可：

`int[] array;`
也可以将方括号置于标识符后面，获得完全一致的结果:
`int array[];`

编译器不允许我们告诉它一个数组有多大。这样便使我们回到了“句柄”的问题上。*此时，我们拥有的一切 就是指向数组的一个句柄，而且尚未给数组分配任何空间*。对于数组，初始化工作可在代码的任何地方出现，但也可以使用一种特殊的初始化表达式，这种特殊的初始化是一系列由花括号封闭起来的值。==存储空间的分配(等价于使用 new)将由编译器在这种情况下进行==。例如：

`int[]a1={1,2,3,4,5 };`
**那么为什么还要定义一个没有数组的数组句柄呢?**
`int[] a2;`
事实上在Java 中，可将一个数组分配给另一个，所以能使用下述语句:
`a2 = a1;`
我们真正准备做的是复制一个句柄，如下：

```java
public class ArrayTest {
    @Test
    public void testDefineArray() {
        int[] a1 = {1, 2, 3, 4, 5};
        int[] a2;
        a2 = a1;
        }
    }
}
```

a1获得了一个初始值，而a2没有；a2将在以后赋值——这种情况下是赋给另一个数组。所有数组都有一个本质成员，可对其进行查询——但不是改变，从而获知数组内包含了多少个元素。==这个成员就是 length==。由于Java数组从元素0开始计数，所以==能索引的最大元素编号是“length-1”==。如超出边界，就生成一个运行期错误（即一个“违例”）。当然，由于需要==检查每个数组的访问==，所以会消耗一定的时间和多余的代码量，而且没有办法把它关闭。这意味着数组访问可能成为程序效率低下的重要原因——如果它们在关键的场合进行。

* <u>程序编写期间，如果不知道在自己的数组里需要多少元素，那么又该怎么办呢？此时，只需简单地用 new 在数组里创建元素</u>：`int[] a = new int[20];`

* 数组的创建实际是在运行期间进行的。
* 基本数据类型的数组元素会自动初始化成“空” 值(对于数值，空值就是零；对于char，它是null；而对于boolean，它却是false)。
* 若操作的是一个非基本类型对象的数组，必须使用new。

`Integer[] a = new Integer[20];`这只是一个句柄数组，而且除非通过创建一个新的Integer对象(a[i] = new Integer(10))，从而初始化对象句柄，否则初始化进程不会结束。

> 数组初始化的两种形式：

```
Integer[] a = {
    new Integer(1),
    new Integer(2),
    new Integer(3),
};

Integer[] b = new Integer[]{
    new Integer(1),
    new Integer(2),
    new Integer(3),
};
```

==数组的大小是在编译期间决定的==。初始化列表的最后一个逗号是可选的(这一特性使长列表的维护变得更加容易)。

### 3. 数组的内存结构

一维数组内存结构：![](https://tva1.sinaimg.cn/large/007S8ZIlgy1givyw3vpp0j30v80kw7c0.jpg)

二维数组的内存结构：![](https://tva1.sinaimg.cn/large/007S8ZIlgy1givyxadmp6j30ts0jmq91.jpg)



### 4. 数组和第一类对象

无论使用的数组属于什么类型，==数组标识符实际都是指向真实对象的一个句柄==。那些对象本身是在内存 “堆”里创建的。堆对象既可“隐式”创建(即默认产生)，亦可“显式”创建(用一个 new 表达式)。堆对象的一部分(实际是我们能访问的唯一字段或方法)是只读的 length成员，它告诉我们那个数组对象里最多能容纳多少元素。对于数组对象，==“[]”语法是我们能采用的唯一另类访问方法==。下面这个例子展示了对数组进行初始化的不同方式，以及如何将数组句柄分配给不同的数组对象。*对象数组和基本数据类型数组唯一的差别在于对象数组容纳的是句柄，而基本数据类型数组容纳的是具体的数值*。

### 5. 数组的返回

假定我们现在想写一个方法，同时不希望它仅仅返回一样东西，而是想返回一系列东西。此时，象C 和C++ 这样的语言会使问题复杂化，因为我们不能返回一个数组，只能返回指向数组的一个指针。这样就非常麻烦，因为很难控制数组的“存在时间”，它很容易造成内存“漏洞”的出现。Java 采用的是类似的方法，但我们能“返回一个数组”。当然，此时返回的实际仍是指向数组的指针。但我们永远不必担心那个数组的是否可用——只要需要，它就会自动存在。而且垃圾收集器会在我们 完成后自动将其清除。

### 6. 遍历数组

* for循环
* for-each循环或加强型循环

### 7. 总结

作为初始化的一种具体操作形式，构建器应使大家明确感受到在语言中进行初始化的严重性。

判断一个程序效率如何，关键是看是否由于变量的初始化不正确而造成了严重的编程错误——bed bugs(臭虫)。

由于构建器使我们能保证正确的初始化和清除（若没有正确的构建器调用，编译器不允许对象创建），所以能获得完全的控制权和安全性。



